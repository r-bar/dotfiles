#!/usr/bin/env python3
import enum
import os
import sys
import shutil
import socket
from abc import ABC, abstractmethod
from typing import Optional, Callable
from subprocess import run, SubprocessError, CompletedProcess
from argparse import ArgumentParser


OSTYPE = os.environ.get('OSTYPE')
CompletedProcess = Callable[[], CompletedProcess]


class Mode(enum.StrEnum):
    IN = 'in'
    OUT = 'out'

class Cli:
    remote: Optional[int]
    stdout: bool

    def __init__(self):
        p = ArgumentParser(description='Inserts into the system clipboard from stdin or prints the clipboard contents to stdout.')
        self.parser = p
        p.add_argument('-r', '--remote', default=None, type=int, help='Send to a remote network socket')
        p.add_argument('-o', '--stdout', action='store_true', help='Force printing to stdout')
        self.args = p.parse_args()
        for name, value in vars(self.args).items():
            setattr(self, name, value)

    def mode(self) -> Mode:
        if self.stdout or sys.stdin.isatty():
            return Mode.OUT
        else:
            return Mode.IN


class SystemClipboard(ABC):
    AVAILABLE_INTERFACES: list['SystemClipboard'] = []

    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        cls.AVAILABLE_INTERFACES.append(cls)

    @classmethod
    @abstractmethod
    def available(cls) -> bool:
        """Determine if the clipboard interface is available."""
        raise NotImplementedError

    @abstractmethod
    def in_cmd(self) -> CompletedProcess:
        """Return the command to write to the clipboard."""
        raise NotImplementedError

    @abstractmethod
    def out_cmd(self) -> CompletedProcess:
        """Return the command to read from the clipboard."""
        raise NotImplementedError

    @classmethod
    def select_clipboard_interface(cls):
        for interface in cls.AVAILABLE_INTERFACES:
            if interface.available():
                return interface()
        raise RuntimeError('No known clipboard interface for the current platform')


class WaylandClipboard(SystemClipboard):
    @staticmethod
    def socket() -> str | None:
        """Determine if the system is running a Wayland display server."""
        return os.environ.get('WAYLAND_DISPLAY')

    @classmethod
    def available(cls) -> bool:
        return cls.socket() is not None

    def in_cmd(self) -> CompletedProcess:
        """Return the command to write to the Wayland clipboard."""
        return run(['wl-copy'], check=True)

    def out_cmd(self) -> CompletedProcess:
        """Return the command to read from the Wayland clipboard."""
        proc = run(['wl-paste'])
        return proc


class X11Clipboard(SystemClipboard):
    @staticmethod
    def socket() -> str | None:
        """Determine if the system is running an X display server."""
        return os.environ.get('DISPLAY')

    @classmethod
    def available(cls) -> bool:
        return cls.socket() is not None

    def in_cmd(self) -> CompletedProcess:
        return run(['xclip', '-selection', 'clipboard', '-in'], check=True)

    def out_cmd(self) -> CompletedProcess:
        return run(['xclip', '-selection', 'clipboard', '-out'])


class XselClipboard(SystemClipboard):
    @staticmethod
    def executable() -> str | None:
        """Determine if the xsel program is available."""
        return shutil.which('xsel')

    @classmethod
    def available(cls) -> bool:
        return cls.executable() is not None

    def in_cmd(self) -> CompletedProcess:
        return run(['xsel', '-b'], check=True)

    def out_cmd(self) -> CompletedProcess:
        return run(['xsel', '-b'])


class MacosClipboard(SystemClipboard):
    @staticmethod
    def available() -> bool:
        return shutil.which('pbcopy') is not None

    def in_cmd(self) -> CompletedProcess:
        return run(['pbcopy'], check=True)

    def out_cmd(self) -> CompletedProcess:
        return run(['pbpaste'])


class CygwinClipboard(SystemClipboard):
    def available(self) -> bool:
        return OSTYPE.startswith('cygwin') or OSTYPE == 'msys'

    def in_cmd(self) -> CompletedProcess:
        return run(['tee', '/dev/clipboard'], check=True)

    def out_cmd(self) -> CompletedProcess:
        return run(['cat', '/dev/clipboard'])

class WslClipboard(SystemClipboard):
    def wsl(self) -> bool:
        """Determine if the system is running Windows Subsystem for Linux."""
        return OSTYPE.startswith('linux')

    def in_cmd(self) -> CompletedProcess:
        return run(['clip.exe'], check=True)

    def out_cmd(self) -> CompletedProcess:
        return run(['powershell.exe', '-Command', 'Get-Clipboard'])


class RemoteClipboard:
    def __init__(self, host: str = '127.0.0.1', port: int = 8377):
        self.port = port

    def daemon_cmd(self) -> CompletedProcess:
        return run(['nc', '-l', str(self.port)])

    def in_cmd(self) -> CompletedProcess:
        return run(['nc', 'localhost', str(self.port)])

    def out_cmd(self) -> CompletedProcess:
        return run(['nc', '-l', str(self.port)])


def main() -> int:
    cli = Cli()
    clipboard = SystemClipboard.select_clipboard_interface()

    if cli.remote:
        raise NotImplementedError('Remote clipboard not implemented yet')
        remote_clipboard = RemoteClipboard(port=cli.remote)

    match cli.mode():
        case Mode.OUT:
            return clipboard.out_cmd().returncode
        case Mode.IN:
            return clipboard.in_cmd().returncode
        case _:
            raise RuntimeError("Unreachable")


if __name__ == '__main__':
    try:
        return_code = main()
    except SubprocessError as exc:
        print(exc.stderr, file=sys.stderr)
        exit(1)
    else:
        exit(return_code)
